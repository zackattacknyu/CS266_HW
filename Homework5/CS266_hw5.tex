\documentclass[11pt,psfig]{article}
\usepackage{epsfig}
\usepackage{times}
\usepackage{amssymb}
\usepackage{float}

\newcount\refno\refno=1
\def\ref{\the\refno \global\advance\refno by 1}
\def\ux{\underline{x}}
\def\uw{\underline{w}}
\def\bw{\underline{w}}
\def\ut{\underline{\theta}}
\def\umu{\underline{\mu}} 
\def\bmu{\underline{\mu}} 
\def\be{p_e^*}
\newcount\eqnumber\eqnumber=1
\def\eq{\the \eqnumber \global\advance\eqnumber by 1}
\def\eqs{\eq}
\def\eqn{\eqno(\eq)}

 \pagestyle{empty}
\def\baselinestretch{1.1}
\topmargin1in \headsep0.3in
\topmargin0in \oddsidemargin0in \textwidth6.5in \textheight8.5in
\begin{document}
\setlength{\parskip}{1.2ex plus0.3ex minus 0.3ex}


\thispagestyle{empty} \pagestyle{myheadings} \markright{G}



\title{CS 266 Homework 5}
\author{Zachary DeStefano, PhD Student, 15247592}
\date{Due Date: May 15}

\maketitle

\vfill\eject

\section*{Problem 10.1}

In Section 10.1 we solved the problem of finding all horizontal line
segments in a set that intersect a vertical segment. For this we used an
interval tree with priority search trees as associated structures. There
is also an alternative approach. We can use a 1-dimensional range tree
on the y-coordinate of the segments to determine those segments whose
y-coordinate lies in the y-range of the query segment. The resulting
segments cannot lie above or below the query segment, but they may
lie completely to the left or to the right of it. We get those segments
in O(logn) canonical subsets. For each of these subsets we use as an
associated structure an interval tree on the x-coordinates to find the
segments that actually intersect the query segment.
q
a. Give the algorithm in pseudocode.
b. Prove that the data structure correctly solves the queries.
c. What are the bounds for preprocessing time, storage, and query time
of this structure? Prove your answers.

\subsection*{Part A}

Here is the algorithm:\\
Traverse binary search tree for y-coordinate until you hit a split vertex\\
Traverse right subtree:\\
- Every time you make a right turn, call the left node n and do Recurse(n)\\
Traverse left subtree:\\
- Every time you make a left turn, call the right node n and do Recurse(n)\\
\\
Recurse(n):\\
- Report intervals in the binary search tree for n that lie in our point.\\
\\

\subsection*{Part B}

We have a binary search tree that will correctly get us the intervals with the correct y-coordinate. We then have an interval tree on our x-coordinates that will get us the matching x's. Thus we will get segments that correctly fit our requirements. \\

\subsection*{Part C}

Preprocessing: \\
The binary search tree can be constructed in $O(n \cdot logn)$\\
Each segment tree can be constructed in $O(n \cdot logn)$ time. \\
Total thus is $O(n^2 log^2(n))$ time. \\
\\
Query: \\
Traversing the first one will take O(log n) operations. \\
Traversing the query time will be done up to log(n) times.\\
For each time, we have a segment tree, so the count will take $log n$ times to obtain. \\
We thus have a query time of $O(log^2(n))$\\
\\
Storage:\\
A binary search tree on the y-coordinate can be stored in $O(n)$ space. \\
The segment trees are each $O(n \cdot log(n))$ space. \\
Thus the total space is $O(n^2 \cdot log(n))$

\newpage

\section*{Problem 10.6c}
Construct a binary search tree of the endpoints. \\
For each leaf in the Binary Search Tree, store the number of overlapping intervals. \\
\\
Construction algorithm:
\begin{verbatim}
-Make a Binary Search Tree of Endpoints
-Sort the list of endpoints
-Initialize currentCount to zero
-For each endpoint in ascending order:
-     If left endpoint:
-          Add one to currentCount
-     If right endpoint:
-          Subtract one from currentCount
-     Put currentCount into endpoint node in Binary Search Tree
\end{verbatim}
Query algorithm to get number of intervals at point q:\\
1. Traverse binary search tree until you find the greatest endpoint that is less than q\\
2. Report its count. \\
\\
Analysis:\\
Construction will be $O(n \cdot logn)$ \\
Query will be $O(logn)$ since it is still a binary search tree \\
Storage will be $O(n)$ since it is just a binary search tree with an added data field in the nodes
\newpage
\section*{Problem 14.6}

In this chapter we called a quadtree balanced if two adjacent squares of
the quadtree subdivision differ by no more than a factor two in size. To
save a constant factor in the number of extra nodes needed to balance a
quadtree, we could weaken the balance condition by allowing adjacent
squares to differ by a factor of four in size. Can you still complete such
a weakly balanced quadtree subdivision to a conforming mesh such that
all angles are between 45◦ and 90◦ by using only O(1) triangles per
square?\\
\\
Now, we cannot do this, because we might end up with obtuse angles if we use the weaker condition. \\
TODO: Insert example, read more page 315 of book

\newpage

\section*{Problem 14.12}

For this algorithm, a vertex v in the quad tree will have this data:\\
- $subtree(i)$ for i=1,2,3,4 will be pointers to subvertices if this square is split up\\
- $value$ will be intensity value if this vertex is a leaf. \\
$J_1$, $J_2$ will denote the quad trees for the images and will point to the root vertex \\
\\
The idea behind this algorithm is that we can traverse the two quad trees concurrently to compute the AND and OR quad trees and potentially take shortcuts. If we are computing the AND tree and we encounter a 0, then we already know that the entire square in the result image will be 0. Similarly, if we are computing the OR tree and we encounter a 1, then we already know that the entire square in the result image will be 1. If we are computing the AND tree and encounter a 1, then the result will be entirely dependent on the other tree. Similarly, if we are computing the OR tree and encounter a zero, then the result is entirely dependent on the other tree.\\
\\
Here are the algorithms in detail:\\
Run GetANDQuadTree($J_1$,$J_2$) and GetORQuadTree($J_1$,$J_2$)
\begin{verbatim}
GetANDQuadTree(I,J):
-     Initialize vertex v with no subtrees or values
-     if both I,J have subtrees:
-          for each subtree i from 1 to 4:
-               v.subtree(i) = GetANDQuadTree(I.subtree(i),J.subtree(i))
-          return v
-     else if both I,J are leaves:
-          v.value = (I.value and J.value)
-     else:
-          let K_1 be the one that is a leaf
-          let K_2 be the one that has a subtree
-          if K_1.value is 0:
-               v.value = 0
-               return v
-          else:
-               for each subtree i from 1 to 4:
-                    v.subtree(i)=K_2.subtree(i)
-               return v
\end{verbatim}
\newpage
\begin{verbatim}
GetORQuadTree(I,J):
-     Initialize vertex v with no subtrees or values
-     if both I,J have subtrees:
-          for each subtree i from 1 to 4:
-               v.subtree(i) = GetORQuadTree(I.subtree(i),J.subtree(i))
-          return v
-     else if both I,J are leaves:
-          v.value = I.value or J.value
-     else:
-          let K_1 be the one that is a leaf
-          let K_2 be the one that has a subtree
-          if K_1.value is 1:
-               v.value = 1
-               return v
-          else:
-               for each subtree i from 1 to 4
-                    v.subtree(i)=K_2.subtree(i)
-               return v

\end{verbatim}


%\begin{figure}[H]
%\centering
%\includegraphics[height=4in]{prob1plot.jpg}
%\caption{Probability of Class Labels with decision boundaries marked}
%\end{figure}


\end{document}








